# Writing good quality code {#best-practice}

This section provides standards for best practice in writing R code. This is one of the most important aspects of coding; it allows you to write code which is easy to use, develop or maintain, simple for other people to read and less prone to errors and bugs.


## Code Layout

Having a clean and consistent layout to every code makes it easy to read and understand, and simplifies the process of improving or fixing code.

### Assigning variables

Variables can be assigned in multiple different ways in R, the most common using `=` or `<-`. Good practice is to only ever use the arrow when assigning variables, leaving `=` for assigning arguments in functions only.

```{r, eval=FALSE}

##Bad; assigning using =
a = 4
vector = seq(from = 1, to = 10, by = 2)

##Good; assigning using <-, using = for function arguments only
a <- 4
vector <- seq(from = 1, to = 10, by = 2)

```

You can use the RStudio shortcut **alt + -** to insert an arrow in your code.

Assignment should only ever happen on the left (beginning) of any code, as assignment at the end is unexpected and easy to miss in code.

```{r, eval=FALSE}

##Bad; assigning at the end
seq(from = 1, to = 10, by = 2) -> vector

##Good; assigning at the start
vector <- seq(from = 1, to = 10, by = 2)

```

### Code spacing

Adding line breaks and spaces into your code makes it more human readable. As a general rule, you should aim to space out code as you would normal text. Add a space either side of mathematical symbols such as `=`, `+`, or `-` and assignment arrows `<-`. Add a space after commas but not before, as you would naturally.


```{r, eval=FALSE}

##Bad; code is squished up and difficult to read
vector<-seq(from=1,to=10,by=2) 

#Good; clearly spaced
vector <- seq(from = 1, to = 10, by = 2)

```

Spacing around brackets is different to normal use:

* When round brackets `()` are used in a function call, don't add a space between the function name and the bracket

```{r, eval=FALSE}
dplyr::filter (mtcars, mpg > 20) #Bad
dplyr::filter(mtcars, mpg > 20) #Good

```

* Curly brackets should start on the same line as the previous function call, and their contents should start on a new line.

```{r, eval=FALSE}
#Bad
function(x){x+1} 

#Good
function(x){
  x+1
} 

```

* Spaces should never be used in colon notation (e.g. `:`, `::`)
```{r, eval = FALSE}
dplyr :: select() #Bad
dplyr::select() #Good

```



### Using package functions

It's good practice to always specify the package associated with a function using the double colon notation:

```{r, eval = FALSE}
select() #Bad
dplyr::select() #Good

pivot_longer() #Bad
tidyr::pivot_longer() #Good
```

This allows a user to understand the origin of each function at a glance, makes debugging easier and also prevents package conflicts. 

### Use of pipes

The "pipe" function `%>%` is taken from the {magrittr} package and is extensively used throughout the tidyverse (and this book!). It takes the object before the pipe and applies it as the first argument in the process after the pipe. Whenever you see a pipe within code, you can therefore read it as an *and then* statement. For example, the code below can be read as "take mtcars *and then* filter on the mpg column, *and then* select the disp and cyl columns.

```{r, eval=FALSE}
mtcars %>% ##and then
  dplyr::filter(mpg > 20) %>% ##and then
  dplyr::select(disp, cyl)
```

Piped code therefore works in exactly the same way as standard nested code, but is significantly easier to read, particularly as you do multiple operations on the same dataset. Below is an example of the same operations carried out using nested code and also piped code:

```{r, eval=FALSE}
#This code is nested and difficult to read and understand
 dplyr::summarise(dplyr::group_by(dplyr::filter(mtcars, am == 1), gear, carb, vs), disp = mean(disp, na.rm = TRUE)) 

#This code is piped and easy to read
mtcars %>% 
  dplyr::filter(am == 1) %>% 
  dplyr::group_by(gear, carb, vs) %>%
  dplyr::summarise(disp = mean(disp, na.rm = TRUE)) 
```

Piping also works on many non-tidyverse functions; for those which do not take the dataset as the first option, you will need to name the other arguments in the function, e.g:

```{r, eval=FALSE}
mtcars %>% 
#In this openxlsx function, the first argument is the workbook name and the second is the data frame
#The data can be piped in as long as the first argument is named, meaning the piped data is passed to the second argument
openxlsx::writeData(wb = test1) 

```


The most common example of code which does not work with piping is from the {ggplot2} package. Here, ggproto objects are added to the original ggplot call using `+`, which cannot be substituted for a pipe. You can however still pipe data objects into a ggplot:

```{r, eval=FALSE}
mtcars %>%
  dplyr::filter(mpg > 20) %>%
  dplyr::select(disp, cyl) %>%
  
  #Data can be piped into the ggplot call
  ggplot2::ggplot(aes(x = disp, y = cyl))+
  
  #Subsequent ggproto objects must be added, not piped
    geom_point()
```

### Code width

The width of each line of code on the screen has a big impact on how easy it is to read. It's easy to miss content which goes off the end of the screen, and annoying to keep scrolling horizontally.

Older style guides recommend that each line of code should be no more than 80 characters, whereas more modern guides designed for larger screens suggest 120 characters. Either way, you should ensure that your code always fits comfortably on the screen when using a laptop.

Any single line of code which goes over this limit should be broken up using line breaks, and the subsequent lines should be indented (RStudio does this automatically for you).

When adding line breaks to piped code, a new line should be started *after* each pipe, not before.

```{r, eval=FALSE}
##Bad; a very long single line of code:
mtcars %>% dplyr::filter(mpg > 20) %>% dplyr::select(disp, cyl) %>% dplyr::arrange(cyl)

#Good; code with line breaks after each pipe and indentation of subsequent lines
mtcars %>% 
  dplyr::filter(mpg > 20) %>% 
  dplyr::select(disp, cyl) %>% 
  dplyr::arrange(cyl)
  

```

When adding line breaks to a single long function, it's good practice to add one after each argument:

```{r, eval=FALSE}
##Bad; a very long single line of code:
dplyr::mutate(mtcars, mpg_grouped = dplyr::case_when(mpg <= 15 ~ "Poor", mpg > 15 & mpg <= 25 ~ "Average", mpg > 25 ~ "Good"))

#Good; code with line breaks after each argument and indentation of subsequent lines
dplyr::mutate(mtcars, 
              mpg_grouped = dplyr::case_when(
                mpg <= 15 ~ "Poor", 
                mpg > 15 & mpg <= 25 ~ "Average", 
                mpg > 25 ~ "Good")
              )
  

```


RStudio comes with an inbuilt code length guide on the script window; this grey line shows you how wide 80 characters is. You can adjust this to 120 characters by going to **Tools -> Global Optionsâ€¦ -> Code -> Display**.


### Code length

-Horizontal and vertical length of code

-Sourcing files to reduce file length


### Linters 

If it seems a bit daunting to implement coding best practice, don't panic! There are tools available, known as linters, which will check your code for you and point out the areas where you can improve.

The easiest one to use in R is the {lintr} library. You can use the `lint()` and `lint_dir()` functions to check your code, with the functions returning a line-by-line breakdown of issues it has spotted in your code.

```{r, eval=FALSE}
library(lintr)

#Check the code in a single file
lintr::lint(your_file_name)

#Check all the code in a whole directory
lintr::lint_dir(your_directory)
```

## Project structure

-One purpose per file
-README files
-Single central file to call all other files
-Folders for raw data, clean data, outputs
-Save clean data as hard copy for QA/multiple outputs as well
-Github for version control
